{
  "auth.email()": {
    "schema": "auth",
    "name": "email",
    "arguments": "",
    "comment": "Deprecated. Use auth.jwt() -> 'email' instead.",
    "sql": "CREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n"
  },
  "auth.jwt()": {
    "schema": "auth",
    "name": "jwt",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n"
  },
  "auth.role()": {
    "schema": "auth",
    "name": "role",
    "arguments": "",
    "comment": "Deprecated. Use auth.jwt() -> 'role' instead.",
    "sql": "CREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n"
  },
  "auth.uid()": {
    "schema": "auth",
    "name": "uid",
    "arguments": "",
    "comment": "Deprecated. Use auth.jwt() -> 'sub' instead.",
    "sql": "CREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Return current user ID from context or default for testing\n    RETURN COALESCE(\n        current_setting('app.current_user_id', true)::UUID,\n        (SELECT id FROM users LIMIT 1)\n    );\nEND;\n$function$\n"
  },
  "extensions.algorithm_sign(signables text, secret text, algorithm text)": {
    "schema": "extensions",
    "name": "algorithm_sign",
    "arguments": "signables text, secret text, algorithm text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.algorithm_sign(signables text, secret text, algorithm text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  alg AS (\n    SELECT CASE\n      WHEN algorithm = 'HS256' THEN 'sha256'\n      WHEN algorithm = 'HS384' THEN 'sha384'\n      WHEN algorithm = 'HS512' THEN 'sha512'\n      ELSE '' END AS id)  -- hmac throws error\nSELECT extensions.url_encode(extensions.hmac(signables, secret, alg.id)) FROM alg;\n$function$\n"
  },
  "extensions.armor(bytea, text[], text[])": {
    "schema": "extensions",
    "name": "armor",
    "arguments": "bytea, text[], text[]",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  "extensions.armor(bytea)": {
    "schema": "extensions",
    "name": "armor",
    "arguments": "bytea",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  "extensions.crypt(text, text)": {
    "schema": "extensions",
    "name": "crypt",
    "arguments": "text, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n"
  },
  "extensions.dearmor(text)": {
    "schema": "extensions",
    "name": "dearmor",
    "arguments": "text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n"
  },
  "extensions.decrypt(bytea, bytea, text)": {
    "schema": "extensions",
    "name": "decrypt",
    "arguments": "bytea, bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n"
  },
  "extensions.decrypt_iv(bytea, bytea, bytea, text)": {
    "schema": "extensions",
    "name": "decrypt_iv",
    "arguments": "bytea, bytea, bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n"
  },
  "extensions.digest(text, text)": {
    "schema": "extensions",
    "name": "digest",
    "arguments": "text, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  "extensions.digest(bytea, text)": {
    "schema": "extensions",
    "name": "digest",
    "arguments": "bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  "extensions.encrypt(bytea, bytea, text)": {
    "schema": "extensions",
    "name": "encrypt",
    "arguments": "bytea, bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n"
  },
  "extensions.encrypt_iv(bytea, bytea, bytea, text)": {
    "schema": "extensions",
    "name": "encrypt_iv",
    "arguments": "bytea, bytea, bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n"
  },
  "extensions.gen_random_bytes(integer)": {
    "schema": "extensions",
    "name": "gen_random_bytes",
    "arguments": "integer",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n"
  },
  "extensions.gen_random_uuid()": {
    "schema": "extensions",
    "name": "gen_random_uuid",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n"
  },
  "extensions.gen_salt(text)": {
    "schema": "extensions",
    "name": "gen_salt",
    "arguments": "text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n"
  },
  "extensions.gen_salt(text, integer)": {
    "schema": "extensions",
    "name": "gen_salt",
    "arguments": "text, integer",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n"
  },
  "extensions.grant_pg_cron_access()": {
    "schema": "extensions",
    "name": "grant_pg_cron_access",
    "arguments": "",
    "comment": "Grants access to pg_cron",
    "sql": "CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n$function$\n"
  },
  "extensions.grant_pg_graphql_access()": {
    "schema": "extensions",
    "name": "grant_pg_graphql_access",
    "arguments": "",
    "comment": "Grants access to pg_graphql",
    "sql": "CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n$function$\n"
  },
  "extensions.grant_pg_net_access()": {
    "schema": "extensions",
    "name": "grant_pg_net_access",
    "arguments": "",
    "comment": "Grants access to pg_net",
    "sql": "CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    IF NOT EXISTS (\n      SELECT 1\n      FROM pg_roles\n      WHERE rolname = 'supabase_functions_admin'\n    )\n    THEN\n      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n    END IF;\n\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    IF EXISTS (\n      SELECT FROM pg_extension\n      WHERE extname = 'pg_net'\n      -- all versions in use on existing projects as of 2025-02-20\n      -- version 0.12.0 onwards don't need these applied\n      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')\n    ) THEN\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    END IF;\n  END IF;\nEND;\n$function$\n"
  },
  "extensions.hmac(text, text, text)": {
    "schema": "extensions",
    "name": "hmac",
    "arguments": "text, text, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  "extensions.hmac(bytea, bytea, text)": {
    "schema": "extensions",
    "name": "hmac",
    "arguments": "bytea, bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  "extensions.pgp_armor_headers(text, OUT key text, OUT value text)": {
    "schema": "extensions",
    "name": "pgp_armor_headers",
    "arguments": "text, OUT key text, OUT value text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n"
  },
  "extensions.pgp_key_id(bytea)": {
    "schema": "extensions",
    "name": "pgp_key_id",
    "arguments": "bytea",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n"
  },
  "extensions.pgp_pub_decrypt(bytea, bytea, text, text)": {
    "schema": "extensions",
    "name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea, text, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  "extensions.pgp_pub_decrypt(bytea, bytea)": {
    "schema": "extensions",
    "name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  "extensions.pgp_pub_decrypt(bytea, bytea, text)": {
    "schema": "extensions",
    "name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  "extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)": {
    "schema": "extensions",
    "name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea, text, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  "extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)": {
    "schema": "extensions",
    "name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  "extensions.pgp_pub_decrypt_bytea(bytea, bytea)": {
    "schema": "extensions",
    "name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  "extensions.pgp_pub_encrypt(text, bytea)": {
    "schema": "extensions",
    "name": "pgp_pub_encrypt",
    "arguments": "text, bytea",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  "extensions.pgp_pub_encrypt(text, bytea, text)": {
    "schema": "extensions",
    "name": "pgp_pub_encrypt",
    "arguments": "text, bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  "extensions.pgp_pub_encrypt_bytea(bytea, bytea)": {
    "schema": "extensions",
    "name": "pgp_pub_encrypt_bytea",
    "arguments": "bytea, bytea",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  "extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)": {
    "schema": "extensions",
    "name": "pgp_pub_encrypt_bytea",
    "arguments": "bytea, bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  "extensions.pgp_sym_decrypt(bytea, text)": {
    "schema": "extensions",
    "name": "pgp_sym_decrypt",
    "arguments": "bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  "extensions.pgp_sym_decrypt(bytea, text, text)": {
    "schema": "extensions",
    "name": "pgp_sym_decrypt",
    "arguments": "bytea, text, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  "extensions.pgp_sym_decrypt_bytea(bytea, text)": {
    "schema": "extensions",
    "name": "pgp_sym_decrypt_bytea",
    "arguments": "bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  "extensions.pgp_sym_decrypt_bytea(bytea, text, text)": {
    "schema": "extensions",
    "name": "pgp_sym_decrypt_bytea",
    "arguments": "bytea, text, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  "extensions.pgp_sym_encrypt(text, text)": {
    "schema": "extensions",
    "name": "pgp_sym_encrypt",
    "arguments": "text, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  "extensions.pgp_sym_encrypt(text, text, text)": {
    "schema": "extensions",
    "name": "pgp_sym_encrypt",
    "arguments": "text, text, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  "extensions.pgp_sym_encrypt_bytea(bytea, text)": {
    "schema": "extensions",
    "name": "pgp_sym_encrypt_bytea",
    "arguments": "bytea, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  "extensions.pgp_sym_encrypt_bytea(bytea, text, text)": {
    "schema": "extensions",
    "name": "pgp_sym_encrypt_bytea",
    "arguments": "bytea, text, text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  "extensions.pgrst_ddl_watch()": {
    "schema": "extensions",
    "name": "pgrst_ddl_watch",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  "extensions.pgrst_drop_watch()": {
    "schema": "extensions",
    "name": "pgrst_drop_watch",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  "extensions.set_graphql_placeholder()": {
    "schema": "extensions",
    "name": "set_graphql_placeholder",
    "arguments": "",
    "comment": "Reintroduces placeholder function for graphql_public.graphql",
    "sql": "CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n$function$\n"
  },
  "extensions.sign(payload json, secret text, algorithm text)": {
    "schema": "extensions",
    "name": "sign",
    "arguments": "payload json, secret text, algorithm text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.sign(payload json, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  header AS (\n    SELECT extensions.url_encode(convert_to('{\"alg\":\"' || algorithm || '\",\"typ\":\"JWT\"}', 'utf8')) AS data\n    ),\n  payload AS (\n    SELECT extensions.url_encode(convert_to(payload::text, 'utf8')) AS data\n    ),\n  signables AS (\n    SELECT header.data || '.' || payload.data AS data FROM header, payload\n    )\nSELECT\n    signables.data || '.' ||\n    extensions.algorithm_sign(signables.data, secret, algorithm) FROM signables;\n$function$\n"
  },
  "extensions.try_cast_double(inp text)": {
    "schema": "extensions",
    "name": "try_cast_double",
    "arguments": "inp text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.try_cast_double(inp text)\n RETURNS double precision\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n  BEGIN\n    BEGIN\n      RETURN inp::double precision;\n    EXCEPTION\n      WHEN OTHERS THEN RETURN NULL;\n    END;\n  END;\n$function$\n"
  },
  "extensions.url_decode(data text)": {
    "schema": "extensions",
    "name": "url_decode",
    "arguments": "data text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.url_decode(data text)\n RETURNS bytea\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH t AS (SELECT translate(data, '-_', '+/') AS trans),\n     rem AS (SELECT length(t.trans) % 4 AS remainder FROM t) -- compute padding size\n    SELECT decode(\n        t.trans ||\n        CASE WHEN rem.remainder > 0\n           THEN repeat('=', (4 - rem.remainder))\n           ELSE '' END,\n    'base64') FROM t, rem;\n$function$\n"
  },
  "extensions.url_encode(data bytea)": {
    "schema": "extensions",
    "name": "url_encode",
    "arguments": "data bytea",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.url_encode(data bytea)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    SELECT translate(encode(data, 'base64'), E'+/=\\n', '-_');\n$function$\n"
  },
  "extensions.uuid_generate_v1()": {
    "schema": "extensions",
    "name": "uuid_generate_v1",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n"
  },
  "extensions.uuid_generate_v1mc()": {
    "schema": "extensions",
    "name": "uuid_generate_v1mc",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n"
  },
  "extensions.uuid_generate_v3(namespace uuid, name text)": {
    "schema": "extensions",
    "name": "uuid_generate_v3",
    "arguments": "namespace uuid, name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n"
  },
  "extensions.uuid_generate_v4()": {
    "schema": "extensions",
    "name": "uuid_generate_v4",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n"
  },
  "extensions.uuid_generate_v5(namespace uuid, name text)": {
    "schema": "extensions",
    "name": "uuid_generate_v5",
    "arguments": "namespace uuid, name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n"
  },
  "extensions.uuid_nil()": {
    "schema": "extensions",
    "name": "uuid_nil",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n"
  },
  "extensions.uuid_ns_dns()": {
    "schema": "extensions",
    "name": "uuid_ns_dns",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n"
  },
  "extensions.uuid_ns_oid()": {
    "schema": "extensions",
    "name": "uuid_ns_oid",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n"
  },
  "extensions.uuid_ns_url()": {
    "schema": "extensions",
    "name": "uuid_ns_url",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n"
  },
  "extensions.uuid_ns_x500()": {
    "schema": "extensions",
    "name": "uuid_ns_x500",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n"
  },
  "extensions.verify(token text, secret text, algorithm text)": {
    "schema": "extensions",
    "name": "verify",
    "arguments": "token text, secret text, algorithm text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION extensions.verify(token text, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS TABLE(header json, payload json, valid boolean)\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  SELECT\n    jwt.header AS header,\n    jwt.payload AS payload,\n    jwt.signature_ok AND tstzrange(\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'nbf')),\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'exp'))\n    ) @> CURRENT_TIMESTAMP AS valid\n  FROM (\n    SELECT\n      convert_from(extensions.url_decode(r[1]), 'utf8')::json AS header,\n      convert_from(extensions.url_decode(r[2]), 'utf8')::json AS payload,\n      r[3] = extensions.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS signature_ok\n    FROM regexp_split_to_array(token, '\\.') r\n  ) jwt\n$function$\n"
  },
  "graphql_public.graphql(\"operationName\" text, query text, variables jsonb, extensions jsonb)": {
    "schema": "graphql_public",
    "name": "graphql",
    "arguments": "\"operationName\" text, query text, variables jsonb, extensions jsonb",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $function$\n"
  },
  "pgbouncer.get_auth(p_usename text)": {
    "schema": "pgbouncer",
    "name": "get_auth",
    "arguments": "p_usename text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)\n RETURNS TABLE(username text, password text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RAISE WARNING 'PgBouncer auth request: %', p_usename;\n\n    RETURN QUERY\n    SELECT usename::TEXT, passwd::TEXT FROM pg_catalog.pg_shadow\n    WHERE usename = p_usename;\nEND;\n$function$\n"
  },
  "public.add_invoice_history_entry(p_invoice_id integer, p_event_type character varying, p_action character varying, p_description text, p_metadata jsonb)": {
    "schema": "public",
    "name": "add_invoice_history_entry",
    "arguments": "p_invoice_id integer, p_event_type character varying, p_action character varying, p_description text, p_metadata jsonb",
    "comment": "Функция для ручного добавления записей в историю счетов",
    "sql": "CREATE OR REPLACE FUNCTION public.add_invoice_history_entry(p_invoice_id integer, p_event_type character varying, p_action character varying, p_description text DEFAULT NULL::text, p_metadata jsonb DEFAULT NULL::jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_user_id UUID;\n    v_user_name VARCHAR(255);\n    v_user_role VARCHAR(100);\nBEGIN\n    -- Получаем информацию о пользователе\n    v_user_id := auth.uid();\n\n    IF v_user_id IS NOT NULL THEN\n        SELECT u.full_name, r.name\n        INTO v_user_name, v_user_role\n        FROM public.users u\n        LEFT JOIN public.roles r ON u.role_id = r.id\n        WHERE u.id = v_user_id;\n    END IF;\n\n    -- Добавляем запись в историю\n    INSERT INTO public.invoice_history (\n        invoice_id, event_type, action,\n        user_id, user_name, user_role,\n        description, metadata\n    ) VALUES (\n        p_invoice_id,\n        p_event_type,\n        p_action,\n        v_user_id,\n        COALESCE(v_user_name, 'Система'),\n        v_user_role,\n        p_description,\n        p_metadata\n    );\nEND;\n$function$\n"
  },
  "public.calculate_payment_vat()": {
    "schema": "public",
    "name": "calculate_payment_vat",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.calculate_payment_vat()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Если указана общая сумма и ставка НДС, но не указаны детали НДС\n    IF NEW.total_amount IS NOT NULL\n       AND NEW.vat_rate IS NOT NULL\n       AND NEW.amount_net IS NULL\n       AND NEW.vat_amount IS NULL THEN\n\n        -- Рассчитываем НДС и сумму без НДС (обратный расчет от суммы с НДС)\n        IF NEW.vat_rate > 0 THEN\n            NEW.vat_amount := ROUND(NEW.total_amount * NEW.vat_rate / (100 + NEW.vat_rate), 2);\n            NEW.amount_net := NEW.total_amount - NEW.vat_amount;\n        ELSE\n            NEW.vat_amount := 0;\n            NEW.amount_net := NEW.total_amount;\n        END IF;\n\n    -- Если указана сумма без НДС и ставка НДС\n    ELSIF NEW.amount_net IS NOT NULL\n          AND NEW.vat_rate IS NOT NULL\n          AND NEW.total_amount IS NULL THEN\n\n        -- Рассчитываем НДС и общую сумму (прямой расчет)\n        IF NEW.vat_rate > 0 THEN\n            NEW.vat_amount := ROUND(NEW.amount_net * NEW.vat_rate / 100, 2);\n            NEW.total_amount := NEW.amount_net + NEW.vat_amount;\n        ELSE\n            NEW.vat_amount := 0;\n            NEW.total_amount := NEW.amount_net;\n        END IF;\n\n    -- Если указаны все суммы, проверяем корректность\n    ELSIF NEW.total_amount IS NOT NULL\n          AND NEW.amount_net IS NOT NULL\n          AND NEW.vat_amount IS NOT NULL THEN\n\n        -- Проверяем, что total_amount = amount_net + vat_amount\n        IF ABS(NEW.total_amount - (NEW.amount_net + NEW.vat_amount)) > 0.01 THEN\n            RAISE EXCEPTION 'Некорректные суммы НДС: total_amount (%) != amount_net (%) + vat_amount (%)',\n                            NEW.total_amount, NEW.amount_net, NEW.vat_amount;\n        END IF;\n    END IF;\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  "public.cascade_delete_invoice(p_invoice_id integer)": {
    "schema": "public",
    "name": "cascade_delete_invoice",
    "arguments": "p_invoice_id integer",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.cascade_delete_invoice(p_invoice_id integer)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_deleted boolean := false;\nBEGIN\n    -- Отключаем триггеры на время удаления\n    SET LOCAL session_replication_role = 'replica';\n\n    -- Удаляем связанные записи\n    DELETE FROM public.workflow_approval_progress\n    WHERE workflow_id IN (\n        SELECT id FROM public.payment_workflows\n        WHERE invoice_id = p_invoice_id\n    );\n\n    DELETE FROM public.payment_workflows\n    WHERE invoice_id = p_invoice_id;\n\n    DELETE FROM public.payments\n    WHERE invoice_id = p_invoice_id;\n\n    DELETE FROM public.invoice_documents\n    WHERE invoice_id = p_invoice_id;\n\n    DELETE FROM public.invoice_history\n    WHERE invoice_id = p_invoice_id;\n\n    DELETE FROM public.invoices\n    WHERE id = p_invoice_id;\n\n    -- Проверяем, был ли удален счет\n    GET DIAGNOSTICS v_deleted = ROW_COUNT;\n\n    -- Включаем триггеры обратно\n    SET LOCAL session_replication_role = 'origin';\n\n    -- Возвращаем результат\n    IF v_deleted THEN\n        RETURN jsonb_build_object(\n            'success', true,\n            'invoice_id', p_invoice_id,\n            'timestamp', now()\n        );\n    ELSE\n        RETURN jsonb_build_object(\n            'success', false,\n            'invoice_id', p_invoice_id,\n            'error', 'Invoice not found',\n            'timestamp', now()\n        );\n    END IF;\n\nEXCEPTION WHEN OTHERS THEN\n    -- Включаем триггеры обратно в случае ошибки\n    SET LOCAL session_replication_role = 'origin';\n\n    RETURN jsonb_build_object(\n        'success', false,\n        'invoice_id', p_invoice_id,\n        'error', SQLERRM,\n        'timestamp', now()\n    );\nEND;\n$function$\n"
  },
  "public.delete_payment_with_history(p_payment_id integer)": {
    "schema": "public",
    "name": "delete_payment_with_history",
    "arguments": "p_payment_id integer",
    "comment": "Удаляет платеж с сохранением записи в истории. Использовать вместо прямого DELETE.",
    "sql": "CREATE OR REPLACE FUNCTION public.delete_payment_with_history(p_payment_id integer)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_invoice_id INTEGER;\n    v_total_amount DECIMAL;\n    v_internal_number TEXT;\nBEGIN\n    -- Получаем информацию о платеже перед удалением\n    SELECT invoice_id, total_amount, internal_number\n    INTO v_invoice_id, v_total_amount, v_internal_number\n    FROM payments\n    WHERE id = p_payment_id;\n\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Платеж с ID % не найден', p_payment_id;\n    END IF;\n\n    -- Добавляем запись в историю об удалении\n    INSERT INTO invoice_history (\n        invoice_id,\n        event_type,\n        event_date,\n        action,\n        description,\n        payment_id,\n        amount_to,\n        user_id\n    ) VALUES (\n        v_invoice_id,\n        'PAYMENT_DELETED',\n        now(),\n        'Платеж удален',\n        format('Удален платеж %s на сумму %s', v_internal_number, v_total_amount),\n        NULL, -- Не ссылаемся на удаляемый платеж\n        v_total_amount,\n        auth.uid()\n    );\n\n    -- Удаляем платеж (связанные записи истории будут обновлены автоматически)\n    DELETE FROM payments WHERE id = p_payment_id;\nEND;\n$function$\n"
  },
  "public.fn_recalc_invoice_amounts()": {
    "schema": "public",
    "name": "fn_recalc_invoice_amounts",
    "arguments": "",
    "comment": "Recalculates VAT and total amounts before invoice insert/update",
    "sql": "CREATE OR REPLACE FUNCTION public.fn_recalc_invoice_amounts()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Calculate VAT amount based on net amount and VAT rate\n    NEW.vat_amount = ROUND(NEW.amount_net * NEW.vat_rate / 100, 2);\n    \n    -- Calculate total amount (net + VAT)\n    NEW.total_amount = NEW.amount_net + NEW.vat_amount;\n    \n    -- Ensure paid amount doesn't exceed total amount\n    IF NEW.paid_amount > NEW.total_amount THEN\n        NEW.paid_amount = NEW.total_amount;\n    END IF;\n    \n    -- Update payment status based on paid amount\n    IF NEW.paid_amount = 0 THEN\n        -- Status remains as is (could be draft, approved, etc.)\n        NULL;\n    ELSIF NEW.paid_amount >= NEW.total_amount THEN\n        NEW.status = 'paid';\n        IF NEW.paid_at IS NULL THEN\n            NEW.paid_at = NOW();\n        END IF;\n    ELSIF NEW.paid_amount > 0 THEN\n        NEW.status = 'partially_paid';\n    END IF;\n    \n    RETURN NEW;\nEND;\n$function$\n"
  },
  "public.fn_sync_invoice_payment()": {
    "schema": "public",
    "name": "fn_sync_invoice_payment",
    "arguments": "",
    "comment": "Синхронизирует оплаченную сумму счета. Работает ТОЛЬКО с реальными статусами: completed, processing",
    "sql": "CREATE OR REPLACE FUNCTION public.fn_sync_invoice_payment()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    target_invoice_id integer;\n    total_paid numeric(15,2);\n    invoice_total numeric(15,2);\n    v_last_payment_date timestamp with time zone;\n    v_old_status character varying(50);\nBEGIN\n    -- Определяем целевой счет\n    IF TG_OP = 'DELETE' THEN\n        target_invoice_id := OLD.invoice_id;\n    ELSE\n        target_invoice_id := NEW.invoice_id;\n    END IF;\n\n    -- Получаем старый статус счета\n    SELECT status INTO v_old_status\n    FROM invoices\n    WHERE id = target_invoice_id;\n\n    -- Вычисляем общую сумму оплаченных платежей\n    SELECT\n        COALESCE(SUM(total_amount), 0),\n        MAX(payment_date)\n    INTO\n        total_paid,\n        v_last_payment_date\n    FROM payments\n    WHERE invoice_id = target_invoice_id\n        AND status IN ('completed', 'processing');\n\n    -- Получаем общую сумму счета\n    SELECT total_amount\n    INTO invoice_total\n    FROM invoices\n    WHERE id = target_invoice_id;\n\n    -- Обновляем счет\n    UPDATE invoices\n    SET\n        paid_amount = total_paid,\n        paid_at = CASE\n            WHEN total_paid >= invoice_total AND paid_at IS NULL\n                THEN COALESCE(v_last_payment_date, NOW())\n            WHEN total_paid < invoice_total\n                THEN NULL\n            ELSE paid_at\n        END,\n        status = CASE\n            WHEN total_paid = 0 THEN 'draft'\n            WHEN total_paid > 0 AND total_paid < invoice_total THEN 'partially_paid'\n            WHEN total_paid >= invoice_total THEN 'paid'\n            ELSE status\n        END,\n        updated_at = NOW()\n    WHERE id = target_invoice_id;\n\n    -- Логирование для отладки\n    IF TG_OP IN ('INSERT', 'UPDATE') THEN\n        RAISE NOTICE 'Синхронизация счета #%: paid=% of %, status=%',\n            target_invoice_id, total_paid, invoice_total, NEW.status;\n\n        -- Записываем в историю с использованием NEW.created_by\n        INSERT INTO public.invoice_history (\n            invoice_id,\n            payment_id,\n            event_type,\n            event_date,\n            action,\n            description,\n            status_from,\n            status_to,\n            amount_from,\n            amount_to,\n            changed_fields,\n            user_id,\n            created_at\n        ) VALUES (\n            target_invoice_id,\n            NEW.id,\n            'payment',\n            NOW(),\n            'payment_sync',\n            format('Синхронизация платежей: %s из %s', total_paid::money, invoice_total::money),\n            v_old_status,\n            (SELECT status FROM invoices WHERE id = target_invoice_id),\n            (SELECT paid_amount FROM invoices WHERE id = target_invoice_id) - NEW.total_amount,\n            total_paid,\n            jsonb_build_object(\n                'payment_status', NEW.status,\n                'payment_amount', NEW.total_amount,\n                'total_paid', total_paid\n            ),\n            NEW.created_by,  -- Теперь это поле существует!\n            NOW()\n        );\n    END IF;\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  "public.get_current_user_profile()": {
    "schema": "public",
    "name": "get_current_user_profile",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.get_current_user_profile()\n RETURNS SETOF users\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\n    SELECT * FROM public.users WHERE id = auth.uid();\n$function$\n"
  },
  "public.get_invoice_history(p_invoice_id integer)": {
    "schema": "public",
    "name": "get_invoice_history",
    "arguments": "p_invoice_id integer",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.get_invoice_history(p_invoice_id integer)\n RETURNS TABLE(id bigint, action character varying, action_description text, user_name character varying, user_role character varying, changed_fields text[], comment text, created_at timestamp with time zone, status_from character varying, status_to character varying, workflow_stage_from character varying, workflow_stage_to character varying, invoice_id integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT\n        ial.id,\n        ial.action,\n        CASE\n            WHEN ial.action = 'CREATE' THEN 'Создан счет'\n            WHEN ial.action = 'STATUS_CHANGE' THEN 'Изменен статус: ' || COALESCE(ial.status_from, 'нет') || ' → ' || COALESCE(ial.status_to, 'нет')\n            WHEN ial.action = 'UPDATE' THEN 'Изменены поля: ' || COALESCE(array_to_string(ial.changed_fields, ', '), '')\n            WHEN ial.action = 'DELETE' THEN 'Удален счет'\n            WHEN ial.action = 'COMMENT' THEN 'Добавлен комментарий'\n            ELSE ial.action\n        END::TEXT as action_description,\n        ial.user_name,\n        COALESCE(r.name, 'Неизвестная роль')::VARCHAR(255) as user_role,\n        ial.changed_fields,\n        ial.comment,\n        ial.created_at,\n        ial.status_from,\n        ial.status_to,\n        ial.workflow_stage_from,\n        ial.workflow_stage_to,\n        ial.invoice_id\n    FROM invoice_audit_log ial\n    LEFT JOIN users u ON ial.user_id = u.id\n    LEFT JOIN roles r ON u.role_id = r.id\n    WHERE ial.invoice_id = p_invoice_id\n    ORDER BY ial.created_at DESC;\nEND;\n$function$\n"
  },
  "public.get_next_invoice_sequence(p_org_code character varying, p_proj_code character varying, p_year_month character varying)": {
    "schema": "public",
    "name": "get_next_invoice_sequence",
    "arguments": "p_org_code character varying, p_proj_code character varying, p_year_month character varying",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.get_next_invoice_sequence(p_org_code character varying, p_proj_code character varying, p_year_month character varying)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  v_max_seq INTEGER;\n  v_pattern VARCHAR;\nBEGIN\n  -- Формируем паттерн для поиска\n  v_pattern := p_org_code || '-' || p_proj_code || '-%%-INV-' || p_year_month || '-%';\n  \n  -- Находим максимальный sequence для данного паттерна\n  SELECT COALESCE(\n    MAX(\n      CAST(\n        SUBSTRING(internal_number FROM '[0-9]{3}$') AS INTEGER\n      )\n    ), \n    0\n  ) INTO v_max_seq\n  FROM invoices\n  WHERE internal_number LIKE v_pattern;\n  \n  -- Возвращаем следующий номер\n  RETURN v_max_seq + 1;\nEND;\n$function$\n"
  },
  "public.get_next_payment_sequence(p_invoice_id integer)": {
    "schema": "public",
    "name": "get_next_payment_sequence",
    "arguments": "p_invoice_id integer",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.get_next_payment_sequence(p_invoice_id integer)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  v_max_seq INTEGER;\n  v_invoice_internal_number VARCHAR;\n  v_pattern VARCHAR;\nBEGIN\n  -- Получаем внутренний номер счета\n  SELECT internal_number INTO v_invoice_internal_number\n  FROM invoices\n  WHERE id = p_invoice_id;\n  \n  -- Если у счета нет внутреннего номера, возвращаем 1\n  IF v_invoice_internal_number IS NULL THEN\n    RETURN 1;\n  END IF;\n  \n  -- Формируем паттерн для поиска\n  v_pattern := v_invoice_internal_number || '/PAY-%';\n  \n  -- Находим максимальный sequence для данного счета\n  SELECT COALESCE(\n    MAX(\n      CAST(\n        SUBSTRING(internal_number FROM '.*PAY-([0-9]{2})-.*') AS INTEGER\n      )\n    ), \n    0\n  ) INTO v_max_seq\n  FROM payments\n  WHERE internal_number LIKE v_pattern;\n  \n  -- Возвращаем следующий номер\n  RETURN v_max_seq + 1;\nEND;\n$function$\n"
  },
  "public.get_payment_history(p_payment_id integer)": {
    "schema": "public",
    "name": "get_payment_history",
    "arguments": "p_payment_id integer",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.get_payment_history(p_payment_id integer)\n RETURNS TABLE(id bigint, action character varying, action_description text, user_name character varying, user_role character varying, changed_fields text[], comment text, created_at timestamp with time zone, status_from character varying, status_to character varying, amount_from numeric, amount_to numeric, payment_id integer, invoice_id integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT\n        pal.id,\n        pal.action,\n        CASE\n            WHEN pal.action = 'CREATE' THEN 'Создан платеж на сумму ' || COALESCE(pal.amount_to::TEXT, '0')\n            WHEN pal.action = 'STATUS_CHANGE' THEN 'Изменен статус: ' || COALESCE(pal.status_from, 'нет') || ' → ' || COALESCE(pal.status_to, 'нет')\n            WHEN pal.action = 'AMOUNT_CHANGE' THEN 'Изменена сумма: ' || COALESCE(pal.amount_from::TEXT, '0') || ' → ' || COALESCE(pal.amount_to::TEXT, '0')\n            WHEN pal.action = 'UPDATE' THEN 'Изменены поля: ' || COALESCE(array_to_string(pal.changed_fields, ', '), '')\n            WHEN pal.action = 'DELETE' THEN 'Удален платеж'\n            WHEN pal.action = 'COMMENT' THEN 'Добавлен комментарий'\n            ELSE pal.action\n        END::TEXT as action_description,\n        pal.user_name,\n        COALESCE(r.name, 'Неизвестная роль')::VARCHAR(255) as user_role,\n        pal.changed_fields,\n        pal.comment,\n        pal.created_at,\n        pal.status_from,\n        pal.status_to,\n        pal.amount_from,\n        pal.amount_to,\n        pal.payment_id,\n        pal.invoice_id\n    FROM payment_audit_log pal\n    LEFT JOIN users u ON pal.user_id = u.id\n    LEFT JOIN roles r ON u.role_id = r.id\n    WHERE pal.payment_id = p_payment_id\n    ORDER BY pal.created_at DESC;\nEND;\n$function$\n"
  },
  "public.get_payment_history_by_invoice(p_invoice_id integer)": {
    "schema": "public",
    "name": "get_payment_history_by_invoice",
    "arguments": "p_invoice_id integer",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.get_payment_history_by_invoice(p_invoice_id integer)\n RETURNS TABLE(id bigint, action character varying, action_description text, user_name character varying, user_role character varying, changed_fields text[], comment text, created_at timestamp with time zone, status_from character varying, status_to character varying, amount_from numeric, amount_to numeric, payment_id integer, invoice_id integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT\n        pal.id,\n        pal.action,\n        CASE\n            WHEN pal.action = 'CREATE' THEN 'Создан платеж на сумму ' || COALESCE(pal.amount_to::TEXT, '0')\n            WHEN pal.action = 'STATUS_CHANGE' THEN 'Изменен статус: ' || COALESCE(pal.status_from, 'нет') || ' → ' || COALESCE(pal.status_to, 'нет')\n            WHEN pal.action = 'AMOUNT_CHANGE' THEN 'Изменена сумма: ' || COALESCE(pal.amount_from::TEXT, '0') || ' → ' || COALESCE(pal.amount_to::TEXT, '0')\n            WHEN pal.action = 'UPDATE' THEN 'Изменены поля: ' || COALESCE(array_to_string(pal.changed_fields, ', '), '')\n            WHEN pal.action = 'DELETE' THEN 'Удален платеж'\n            WHEN pal.action = 'COMMENT' THEN 'Добавлен комментарий'\n            ELSE pal.action\n        END::TEXT as action_description,\n        pal.user_name,\n        COALESCE(r.name, 'Неизвестная роль')::VARCHAR(255) as user_role,\n        pal.changed_fields,\n        pal.comment,\n        pal.created_at,\n        pal.status_from,\n        pal.status_to,\n        pal.amount_from,\n        pal.amount_to,\n        pal.payment_id,\n        pal.invoice_id\n    FROM payment_audit_log pal\n    LEFT JOIN users u ON pal.user_id = u.id\n    LEFT JOIN roles r ON u.role_id = r.id\n    WHERE pal.invoice_id = p_invoice_id\n    ORDER BY pal.created_at DESC;\nEND;\n$function$\n"
  },
  "public.get_statuses_by_entity_type(p_entity_type text)": {
    "schema": "public",
    "name": "get_statuses_by_entity_type",
    "arguments": "p_entity_type text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.get_statuses_by_entity_type(p_entity_type text)\n RETURNS TABLE(id bigint, code text, name text, color text, is_final boolean, is_active boolean, order_index integer, description text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n  return query\n  select \n    s.id,\n    s.code,\n    s.name,\n    s.color,\n    s.is_final,\n    s.is_active,\n    s.order_index,\n    s.description\n  from public.statuses s\n  where s.entity_type = p_entity_type\n    and s.is_active = true\n  order by s.order_index, s.name;\nend;\n$function$\n"
  },
  "public.get_workflow_for_invoice(p_invoice_type_id integer)": {
    "schema": "public",
    "name": "get_workflow_for_invoice",
    "arguments": "p_invoice_type_id integer",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.get_workflow_for_invoice(p_invoice_type_id integer)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_workflow_id integer;\nBEGIN\n    -- Получаем первый активный workflow для данного типа заявки\n    SELECT id INTO v_workflow_id\n    FROM public.workflows\n    WHERE is_active = true\n      AND (\n        invoice_type_ids IS NULL\n        OR p_invoice_type_id = ANY(invoice_type_ids)\n      )\n    ORDER BY id ASC\n    LIMIT 1;\n\n    RETURN v_workflow_id;\nEND;\n$function$\n"
  },
  "public.handle_new_user()": {
    "schema": "public",
    "name": "handle_new_user",
    "arguments": "",
    "comment": "Creates user record when new auth user is created",
    "sql": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  BEGIN\n      -- Создаем профиль пользователя\n      INSERT INTO public.users (id, email, full_name, role_id, is_active)\n      VALUES (\n          NEW.id,\n          NEW.email,\n          COALESCE(\n              NEW.raw_user_meta_data->>'full_name',\n              NEW.raw_user_meta_data->>'name',\n              SPLIT_PART(NEW.email, '@', 1)\n          ),\n          (SELECT id FROM roles WHERE code = 'user' LIMIT 1), -- Получаем role_id для роли 'user'\n          true\n      )\n      ON CONFLICT (id) DO UPDATE\n      SET\n          email = EXCLUDED.email,\n          full_name = COALESCE(EXCLUDED.full_name, users.full_name),\n          updated_at = now();\n\n      RETURN NEW;\n  EXCEPTION\n      WHEN OTHERS THEN\n          RAISE WARNING 'Error creating user profile: %', SQLERRM;\n          RETURN NEW;\n  END;\n  $function$\n"
  },
  "public.is_status_final(p_entity_type text, p_code text)": {
    "schema": "public",
    "name": "is_status_final",
    "arguments": "p_entity_type text, p_code text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.is_status_final(p_entity_type text, p_code text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\ndeclare\n  v_is_final boolean;\nbegin\n  select s.is_final into v_is_final\n  from public.statuses s\n  where s.entity_type = p_entity_type\n    and s.code = p_code\n    and s.is_active = true;\n  \n  return coalesce(v_is_final, false);\nend;\n$function$\n"
  },
  "public.set_default_user_role()": {
    "schema": "public",
    "name": "set_default_user_role",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.set_default_user_role()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  default_role_id INTEGER;\nBEGIN\n  -- Получаем ID роли 'user'\n  SELECT id INTO default_role_id \n  FROM roles \n  WHERE code = 'user' \n  LIMIT 1;\n  \n  -- Если роль не найдена, используем ID = 1\n  IF default_role_id IS NULL THEN\n    default_role_id := 1;\n  END IF;\n  \n  -- Устанавливаем роль по умолчанию, если она не указана\n  IF NEW.role_id IS NULL THEN\n    NEW.role_id := default_role_id;\n  END IF;\n  \n  -- Устанавливаем is_active = true по умолчанию\n  IF NEW.is_active IS NULL THEN\n    NEW.is_active := true;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  "public.start_payment_workflow_simple(p_payment_id integer, p_invoice_id integer, p_workflow_id integer, p_user_id uuid, p_amount numeric, p_description text, p_supplier_id integer, p_project_id integer, p_payment_date date)": {
    "schema": "public",
    "name": "start_payment_workflow_simple",
    "arguments": "p_payment_id integer, p_invoice_id integer, p_workflow_id integer, p_user_id uuid, p_amount numeric, p_description text, p_supplier_id integer, p_project_id integer, p_payment_date date",
    "comment": "Запускает процесс согласования платежа. Все ID теперь INTEGER",
    "sql": "CREATE OR REPLACE FUNCTION public.start_payment_workflow_simple(p_payment_id integer, p_invoice_id integer, p_workflow_id integer, p_user_id uuid, p_amount numeric, p_description text DEFAULT NULL::text, p_supplier_id integer DEFAULT NULL::integer, p_project_id integer DEFAULT NULL::integer, p_payment_date date DEFAULT CURRENT_DATE)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_workflow_id integer;\n    v_first_stage_id integer;\n    v_stages_total integer;\nBEGIN\n    -- Валидация обязательных параметров\n    IF p_amount IS NULL OR p_amount <= 0 THEN\n        RAISE EXCEPTION 'Сумма платежа должна быть больше 0';\n    END IF;\n\n    -- Получаем первый этап workflow\n    SELECT id INTO v_first_stage_id\n    FROM public.workflow_stages\n    WHERE workflow_id = p_workflow_id\n    ORDER BY position ASC\n    LIMIT 1;\n\n    IF v_first_stage_id IS NULL THEN\n        RAISE EXCEPTION 'Не найдены этапы для workflow_id = %', p_workflow_id;\n    END IF;\n\n    -- Получаем общее количество этапов\n    SELECT COUNT(*) INTO v_stages_total\n    FROM public.workflow_stages\n    WHERE workflow_id = p_workflow_id;\n\n    -- Создаем запись payment_workflow\n    INSERT INTO public.payment_workflows (\n        payment_id,          -- INTEGER\n        invoice_id,          -- INTEGER\n        workflow_id,\n        current_stage_id,\n        current_stage_position,\n        status,\n        amount,\n        description,\n        contractor_id,\n        project_id,\n        payment_date,\n        stages_total,\n        stages_completed,\n        started_by,\n        started_at\n    ) VALUES (\n        p_payment_id,        -- Прямо передаем INTEGER\n        p_invoice_id,        -- Прямо передаем INTEGER\n        p_workflow_id,\n        v_first_stage_id,\n        1,\n        'in_progress',\n        p_amount,\n        p_description,\n        p_supplier_id,\n        p_project_id,\n        p_payment_date,\n        v_stages_total,\n        0,\n        p_user_id,\n        NOW()\n    )\n    RETURNING id INTO v_workflow_id;\n\n    -- Логирование в правильном формате для invoice_history\n    INSERT INTO public.invoice_history (\n        invoice_id,\n        event_type,\n        event_date,\n        action,\n        description,\n        payment_id,\n        user_id,\n        new_values,\n        created_at\n    ) VALUES (\n        p_invoice_id,\n        'workflow',\n        NOW(),\n        'workflow_started',\n        format('Запущен workflow для платежа #%s на сумму %s', p_payment_id, p_amount::money),\n        p_payment_id,\n        p_user_id,\n        jsonb_build_object(\n            'workflow_id', v_workflow_id,\n            'payment_id', p_payment_id,\n            'amount', p_amount,\n            'supplier_id', p_supplier_id,\n            'project_id', p_project_id\n        ),\n        NOW()\n    );\n\n    RETURN v_workflow_id;\nEND;\n$function$\n"
  },
  "public.track_document_changes()": {
    "schema": "public",
    "name": "track_document_changes",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.track_document_changes()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_user_id UUID;\n    v_user_name VARCHAR(255);\n    v_user_role VARCHAR(100);\n    v_invoice_id INTEGER;\n    v_attachment_info RECORD;\nBEGIN\n    -- Получаем информацию о текущем пользователе\n    v_user_id := auth.uid();\n\n    IF v_user_id IS NOT NULL THEN\n        SELECT u.full_name, r.name\n        INTO v_user_name, v_user_role\n        FROM public.users u\n        LEFT JOIN public.roles r ON u.role_id = r.id\n        WHERE u.id = v_user_id;\n    END IF;\n\n    IF TG_OP = 'DELETE' THEN\n        v_invoice_id := OLD.invoice_id;\n\n        -- Получаем информацию о файле из таблицы attachments\n        SELECT original_name, size_bytes, mime_type\n        INTO v_attachment_info\n        FROM public.attachments\n        WHERE id = OLD.attachment_id;\n\n        INSERT INTO public.invoice_history (\n            invoice_id,\n            document_id,\n            attachment_id,\n            event_type,\n            action,\n            user_id,\n            user_name,\n            user_role,\n            old_values,\n            description,\n            metadata\n        ) VALUES (\n            v_invoice_id,\n            OLD.id,\n            OLD.attachment_id,\n            'DOCUMENT_REMOVED',\n            'Документ удален',\n            v_user_id,\n            COALESCE(v_user_name, 'Система'),\n            v_user_role,\n            to_jsonb(OLD),\n            'Удален документ: ' || COALESCE(v_attachment_info.original_name, 'без имени'),\n            jsonb_build_object(\n                'file_name', v_attachment_info.original_name,\n                'file_size', v_attachment_info.size_bytes,\n                'mime_type', v_attachment_info.mime_type,\n                'attachment_id', OLD.attachment_id,\n                'deleted_at', NOW()\n            )\n        );\n        RETURN OLD;\n\n    ELSIF TG_OP = 'INSERT' THEN\n        -- Получаем информацию о файле из таблицы attachments\n        SELECT original_name, size_bytes, mime_type\n        INTO v_attachment_info\n        FROM public.attachments\n        WHERE id = NEW.attachment_id;\n\n        INSERT INTO public.invoice_history (\n            invoice_id,\n            document_id,\n            attachment_id,\n            event_type,\n            action,\n            user_id,\n            user_name,\n            user_role,\n            new_values,\n            description,\n            metadata\n        ) VALUES (\n            NEW.invoice_id,\n            NEW.id,\n            NEW.attachment_id,\n            'DOCUMENT_ADDED',\n            'Документ добавлен',\n            v_user_id,\n            COALESCE(v_user_name, 'Система'),\n            v_user_role,\n            to_jsonb(NEW),\n            'Добавлен документ: ' || COALESCE(v_attachment_info.original_name, 'без имени'),\n            jsonb_build_object(\n                'file_name', v_attachment_info.original_name,\n                'file_size', v_attachment_info.size_bytes,\n                'mime_type', v_attachment_info.mime_type,\n                'attachment_id', NEW.attachment_id\n            )\n        );\n        RETURN NEW;\n    END IF;\n\n    RETURN NULL;\nEND;\n$function$\n"
  },
  "public.track_invoice_changes()": {
    "schema": "public",
    "name": "track_invoice_changes",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.track_invoice_changes()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_user_id UUID;\n    v_user_name VARCHAR(255);\n    v_user_role VARCHAR(100);\n    v_changed_fields JSONB;\n    v_old_values JSONB;\n    v_new_values JSONB;\n    v_invoice_id INTEGER;\n    v_field_names TEXT;\n    v_temp_name VARCHAR(255);\nBEGIN\n    -- Получаем информацию о текущем пользователе\n    v_user_id := auth.uid();\n\n    IF v_user_id IS NOT NULL THEN\n        SELECT u.full_name, r.name\n        INTO v_user_name, v_user_role\n        FROM public.users u\n        LEFT JOIN public.roles r ON u.role_id = r.id\n        WHERE u.id = v_user_id;\n    END IF;\n\n    IF TG_OP = 'DELETE' THEN\n        -- При удалении записываем ID счета\n        v_invoice_id := OLD.id;\n\n        -- Записываем в историю перед удалением\n        INSERT INTO public.invoice_history (\n            invoice_id,\n            event_type,\n            action,\n            user_id,\n            user_name,\n            user_role,\n            status_from,\n            amount_from,\n            old_values,\n            description,\n            metadata,\n            created_at\n        ) VALUES (\n            v_invoice_id,\n            'INVOICE_DELETED',\n            'Счет удален',\n            v_user_id,\n            COALESCE(v_user_name, 'Система'),\n            v_user_role,\n            OLD.status,\n            OLD.total_amount,\n            to_jsonb(OLD),\n            'Удален счет №' || OLD.invoice_number,\n            jsonb_build_object(\n                'invoice_number', OLD.invoice_number,\n                'internal_number', OLD.internal_number,\n                'supplier_id', OLD.supplier_id,\n                'payer_id', OLD.payer_id,\n                'project_id', OLD.project_id,\n                'material_responsible_person_id', OLD.material_responsible_person_id,\n                'deleted_at', NOW()\n            ),\n            NOW()\n        );\n\n        -- Возвращаем OLD для продолжения удаления\n        RETURN OLD;\n\n    ELSIF TG_OP = 'INSERT' THEN\n        -- Запись о создании счета\n        -- Проверяем существование колонки currency в invoice_history\n        IF EXISTS (\n            SELECT 1 FROM information_schema.columns\n            WHERE table_schema = 'public'\n            AND table_name = 'invoice_history'\n            AND column_name = 'currency'\n        ) THEN\n            INSERT INTO public.invoice_history (\n                invoice_id,\n                event_type,\n                action,\n                user_id,\n                user_name,\n                user_role,\n                status_to,\n                amount_to,\n                currency,  -- Всегда RUB\n                new_values,\n                description,\n                metadata\n            ) VALUES (\n                NEW.id,\n                'INVOICE_CREATED',\n                'Счет создан',\n                v_user_id,\n                COALESCE(v_user_name, 'Система'),\n                v_user_role,\n                NEW.status,\n                NEW.total_amount,\n                'RUB',  -- Жёстко закодированная валюта\n                to_jsonb(NEW),\n                'Создан новый счет №' || NEW.invoice_number,\n                jsonb_build_object(\n                    'material_responsible_person_id', NEW.material_responsible_person_id\n                )\n            );\n        ELSE\n            -- Если колонки currency нет, вставляем без неё\n            INSERT INTO public.invoice_history (\n                invoice_id,\n                event_type,\n                action,\n                user_id,\n                user_name,\n                user_role,\n                status_to,\n                amount_to,\n                new_values,\n                description,\n                metadata\n            ) VALUES (\n                NEW.id,\n                'INVOICE_CREATED',\n                'Счет создан',\n                v_user_id,\n                COALESCE(v_user_name, 'Система'),\n                v_user_role,\n                NEW.status,\n                NEW.total_amount,\n                to_jsonb(NEW),\n                'Создан новый счет №' || NEW.invoice_number,\n                jsonb_build_object(\n                    'material_responsible_person_id', NEW.material_responsible_person_id\n                )\n            );\n        END IF;\n\n    ELSIF TG_OP = 'UPDATE' THEN\n        -- Проверяем изменение статуса\n        IF OLD.status IS DISTINCT FROM NEW.status THEN\n            INSERT INTO public.invoice_history (\n                invoice_id,\n                event_type,\n                action,\n                user_id,\n                user_name,\n                user_role,\n                status_from,\n                status_to,\n                description\n            ) VALUES (\n                NEW.id,\n                'STATUS_CHANGED',\n                'Изменен статус счета',\n                v_user_id,\n                COALESCE(v_user_name, 'Система'),\n                v_user_role,\n                OLD.status,\n                NEW.status,\n                'Статус изменен с \"' || COALESCE(OLD.status, 'нет') || '\" на \"' || NEW.status || '\"'\n            );\n        END IF;\n\n        -- Собираем информацию об измененных полях\n        v_changed_fields := '{}';\n        v_old_values := '{}';\n        v_new_values := '{}';\n\n        -- Проверяем важные поля и собираем старые/новые значения\n        IF OLD.total_amount IS DISTINCT FROM NEW.total_amount THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('total_amount', true);\n            v_old_values := v_old_values || jsonb_build_object('total_amount', OLD.total_amount);\n            v_new_values := v_new_values || jsonb_build_object('total_amount', NEW.total_amount);\n        END IF;\n\n        IF OLD.amount_net IS DISTINCT FROM NEW.amount_net THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('amount_net', true);\n            v_old_values := v_old_values || jsonb_build_object('amount_net', OLD.amount_net);\n            v_new_values := v_new_values || jsonb_build_object('amount_net', NEW.amount_net);\n        END IF;\n\n        IF OLD.vat_amount IS DISTINCT FROM NEW.vat_amount THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('vat_amount', true);\n            v_old_values := v_old_values || jsonb_build_object('vat_amount', OLD.vat_amount);\n            v_new_values := v_new_values || jsonb_build_object('vat_amount', NEW.vat_amount);\n        END IF;\n\n        IF OLD.vat_rate IS DISTINCT FROM NEW.vat_rate THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('vat_rate', true);\n            v_old_values := v_old_values || jsonb_build_object('vat_rate', OLD.vat_rate);\n            v_new_values := v_new_values || jsonb_build_object('vat_rate', NEW.vat_rate);\n        END IF;\n\n        IF OLD.supplier_id IS DISTINCT FROM NEW.supplier_id THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('supplier_id', true);\n            v_old_values := v_old_values || jsonb_build_object('supplier_id', OLD.supplier_id);\n            v_new_values := v_new_values || jsonb_build_object('supplier_id', NEW.supplier_id);\n        END IF;\n\n        IF OLD.payer_id IS DISTINCT FROM NEW.payer_id THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('payer_id', true);\n            v_old_values := v_old_values || jsonb_build_object('payer_id', OLD.payer_id);\n            v_new_values := v_new_values || jsonb_build_object('payer_id', NEW.payer_id);\n        END IF;\n\n        IF OLD.project_id IS DISTINCT FROM NEW.project_id THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('project_id', true);\n            v_old_values := v_old_values || jsonb_build_object('project_id', OLD.project_id);\n            v_new_values := v_new_values || jsonb_build_object('project_id', NEW.project_id);\n        END IF;\n\n        IF OLD.description IS DISTINCT FROM NEW.description THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('description', true);\n            v_old_values := v_old_values || jsonb_build_object('description', OLD.description);\n            v_new_values := v_new_values || jsonb_build_object('description', NEW.description);\n        END IF;\n\n        -- ВАЖНО: Проверка изменения МОЛ (материально ответственного лица)\n        IF OLD.material_responsible_person_id IS DISTINCT FROM NEW.material_responsible_person_id THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('material_responsible_person_id', true);\n            v_old_values := v_old_values || jsonb_build_object('material_responsible_person_id', OLD.material_responsible_person_id);\n            v_new_values := v_new_values || jsonb_build_object('material_responsible_person_id', NEW.material_responsible_person_id);\n\n            -- Получаем имена МОЛ из правильной таблицы\n            IF OLD.material_responsible_person_id IS NOT NULL THEN\n                SELECT full_name INTO v_temp_name\n                FROM public.material_responsible_persons\n                WHERE id = OLD.material_responsible_person_id;\n                IF v_temp_name IS NOT NULL THEN\n                    v_old_values := v_old_values || jsonb_build_object('material_responsible_person_name', v_temp_name);\n                END IF;\n            END IF;\n\n            IF NEW.material_responsible_person_id IS NOT NULL THEN\n                SELECT full_name INTO v_temp_name\n                FROM public.material_responsible_persons\n                WHERE id = NEW.material_responsible_person_id;\n                IF v_temp_name IS NOT NULL THEN\n                    v_new_values := v_new_values || jsonb_build_object('material_responsible_person_name', v_temp_name);\n                END IF;\n            END IF;\n        END IF;\n\n        -- Проверяем дополнительные поля\n        IF OLD.invoice_number IS DISTINCT FROM NEW.invoice_number THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('invoice_number', true);\n            v_old_values := v_old_values || jsonb_build_object('invoice_number', OLD.invoice_number);\n            v_new_values := v_new_values || jsonb_build_object('invoice_number', NEW.invoice_number);\n        END IF;\n\n        IF OLD.internal_number IS DISTINCT FROM NEW.internal_number THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('internal_number', true);\n            v_old_values := v_old_values || jsonb_build_object('internal_number', OLD.internal_number);\n            v_new_values := v_new_values || jsonb_build_object('internal_number', NEW.internal_number);\n        END IF;\n\n        IF OLD.invoice_date IS DISTINCT FROM NEW.invoice_date THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('invoice_date', true);\n            v_old_values := v_old_values || jsonb_build_object('invoice_date', OLD.invoice_date);\n            v_new_values := v_new_values || jsonb_build_object('invoice_date', NEW.invoice_date);\n        END IF;\n\n        -- УДАЛЕНА проверка OLD.currency IS DISTINCT FROM NEW.currency\n        -- так как поля currency больше нет в таблице invoices\n\n        IF OLD.priority IS DISTINCT FROM NEW.priority THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('priority', true);\n            v_old_values := v_old_values || jsonb_build_object('priority', OLD.priority);\n            v_new_values := v_new_values || jsonb_build_object('priority', NEW.priority);\n        END IF;\n\n        IF OLD.delivery_days IS DISTINCT FROM NEW.delivery_days THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('delivery_days', true);\n            v_old_values := v_old_values || jsonb_build_object('delivery_days', OLD.delivery_days);\n            v_new_values := v_new_values || jsonb_build_object('delivery_days', NEW.delivery_days);\n        END IF;\n\n        IF OLD.delivery_days_type IS DISTINCT FROM NEW.delivery_days_type THEN\n            v_changed_fields := v_changed_fields || jsonb_build_object('delivery_days_type', true);\n            v_old_values := v_old_values || jsonb_build_object('delivery_days_type', OLD.delivery_days_type);\n            v_new_values := v_new_values || jsonb_build_object('delivery_days_type', NEW.delivery_days_type);\n        END IF;\n\n        -- Если были изменения полей (кроме статуса)\n        IF v_changed_fields != '{}' THEN\n            -- Формируем список измененных полей\n            SELECT string_agg(field_name, ', ')\n            INTO v_field_names\n            FROM jsonb_object_keys(v_changed_fields) AS field_name;\n\n            -- Проверяем существование колонки currency в invoice_history\n            IF EXISTS (\n                SELECT 1 FROM information_schema.columns\n                WHERE table_schema = 'public'\n                AND table_name = 'invoice_history'\n                AND column_name = 'currency'\n            ) THEN\n                INSERT INTO public.invoice_history (\n                    invoice_id,\n                    event_type,\n                    action,\n                    user_id,\n                    user_name,\n                    user_role,\n                    changed_fields,\n                    old_values,\n                    new_values,\n                    amount_from,\n                    amount_to,\n                    currency,  -- Всегда RUB\n                    description\n                ) VALUES (\n                    NEW.id,\n                    'INVOICE_UPDATED',\n                    'Счет изменен',\n                    v_user_id,\n                    COALESCE(v_user_name, 'Система'),\n                    v_user_role,\n                    v_changed_fields,\n                    v_old_values,\n                    v_new_values,\n                    OLD.total_amount,\n                    NEW.total_amount,\n                    'RUB',  -- Жёстко закодированная валюта\n                    'Изменены поля: ' || COALESCE(v_field_names, 'нет')\n                );\n            ELSE\n                -- Если колонки currency нет, вставляем без неё\n                INSERT INTO public.invoice_history (\n                    invoice_id,\n                    event_type,\n                    action,\n                    user_id,\n                    user_name,\n                    user_role,\n                    changed_fields,\n                    old_values,\n                    new_values,\n                    amount_from,\n                    amount_to,\n                    description\n                ) VALUES (\n                    NEW.id,\n                    'INVOICE_UPDATED',\n                    'Счет изменен',\n                    v_user_id,\n                    COALESCE(v_user_name, 'Система'),\n                    v_user_role,\n                    v_changed_fields,\n                    v_old_values,\n                    v_new_values,\n                    OLD.total_amount,\n                    NEW.total_amount,\n                    'Изменены поля: ' || COALESCE(v_field_names, 'нет')\n                );\n            END IF;\n        END IF;\n    END IF;\n\n    -- Для INSERT и UPDATE возвращаем NEW\n    IF TG_OP != 'DELETE' THEN\n        RETURN NEW;\n    END IF;\n\n    -- Этот код не должен выполняться, но на всякий случай\n    RETURN NULL;\nEND;\n$function$\n"
  },
  "public.track_invoice_changes_optimized()": {
    "schema": "public",
    "name": "track_invoice_changes_optimized",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.track_invoice_changes_optimized()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_user_id uuid;\n    v_user_name text;\n    v_user_role text;\n    v_event_type text;\n    v_action text;\n    v_description text;\n    v_changes jsonb;\nBEGIN\n    -- Получить информацию о пользователе\n    SELECT\n        u.id,\n        u.name,\n        r.name\n    INTO v_user_id, v_user_name, v_user_role\n    FROM public.users u\n    LEFT JOIN public.roles r ON r.id = u.role_id\n    WHERE u.id = auth.uid();\n\n    -- Определить тип события\n    CASE TG_OP\n        WHEN 'INSERT' THEN\n            v_event_type := 'invoice_created';\n            v_action := 'create';\n            v_description := format('Счет создан пользователем %s', COALESCE(v_user_name, 'System'));\n            v_changes := to_jsonb(NEW);\n\n        WHEN 'UPDATE' THEN\n            v_event_type := 'invoice_updated';\n            v_action := 'update';\n            v_description := format('Счет изменен пользователем %s', COALESCE(v_user_name, 'System'));\n            -- Записывать только измененные поля\n            v_changes := jsonb_build_object(\n                'old', jsonb_strip_nulls(to_jsonb(OLD)),\n                'new', jsonb_strip_nulls(to_jsonb(NEW)),\n                'diff', (\n                    SELECT jsonb_object_agg(key, value)\n                    FROM jsonb_each(to_jsonb(NEW))\n                    WHERE to_jsonb(OLD) -> key IS DISTINCT FROM value\n                )\n            );\n\n        WHEN 'DELETE' THEN\n            v_event_type := 'invoice_deleted';\n            v_action := 'delete';\n            v_description := format('Счет удален пользователем %s', COALESCE(v_user_name, 'System'));\n            v_changes := to_jsonb(OLD);\n    END CASE;\n\n    -- Записать в историю\n    INSERT INTO public.invoice_history (\n        invoice_id,\n        event_type,\n        action,\n        description,\n        metadata,\n        user_id,\n        user_name,\n        user_role,\n        created_at\n    ) VALUES (\n        COALESCE(NEW.id, OLD.id),\n        v_event_type,\n        v_action,\n        v_description,\n        v_changes,\n        v_user_id,\n        v_user_name,\n        v_user_role,\n        CURRENT_TIMESTAMP\n    );\n\n    RETURN COALESCE(NEW, OLD);\nEND;\n$function$\n"
  },
  "public.track_payment_history()": {
    "schema": "public",
    "name": "track_payment_history",
    "arguments": "",
    "comment": "Отслеживает изменения платежей. При удалении не создает ссылку на удаляемый платеж.",
    "sql": "CREATE OR REPLACE FUNCTION public.track_payment_history()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- При удалении платежа не пытаемся ссылаться на него\n    IF TG_OP = 'DELETE' THEN\n        INSERT INTO public.invoice_history (\n            invoice_id,\n            event_type,\n            event_date,\n            action,\n            description,\n            payment_id,  -- Будет NULL для удаленного платежа\n            status_from,\n            status_to,\n            amount_from,\n            amount_to,\n            old_values,\n            new_values,\n            user_id\n        ) VALUES (\n            OLD.invoice_id,\n            'PAYMENT_DELETED',\n            now(),\n            'Платеж удален',\n            'Удален платеж ' || COALESCE(OLD.internal_number, 'ID:' || OLD.id) || ' на сумму ' || OLD.total_amount,\n            NULL,  -- Не ссылаемся на удаляемый платеж\n            OLD.status,\n            NULL,\n            OLD.total_amount,\n            NULL,\n            to_jsonb(OLD),\n            NULL,\n            auth.uid()\n        );\n        RETURN OLD;\n    END IF;\n\n    -- При создании платежа\n    IF TG_OP = 'INSERT' THEN\n        INSERT INTO public.invoice_history (\n            invoice_id,\n            event_type,\n            event_date,\n            action,\n            description,\n            payment_id,\n            status_from,\n            status_to,\n            amount_from,\n            amount_to,\n            old_values,\n            new_values,\n            user_id\n        ) VALUES (\n            NEW.invoice_id,\n            'PAYMENT_CREATED',\n            now(),\n            'Платеж создан',\n            'Создан платеж ' || COALESCE(NEW.internal_number, 'ID:' || NEW.id) || ' на сумму ' || NEW.total_amount,\n            NEW.id,\n            NULL,\n            NEW.status,\n            NULL,\n            NEW.total_amount,\n            NULL,\n            to_jsonb(NEW),\n            auth.uid()\n        );\n        RETURN NEW;\n    END IF;\n\n    -- При обновлении платежа\n    IF TG_OP = 'UPDATE' THEN\n        -- Логируем только если изменились важные поля\n        IF OLD.status != NEW.status OR OLD.total_amount != NEW.total_amount THEN\n            INSERT INTO public.invoice_history (\n                invoice_id,\n                event_type,\n                event_date,\n                action,\n                description,\n                payment_id,\n                status_from,\n                status_to,\n                amount_from,\n                amount_to,\n                old_values,\n                new_values,\n                user_id\n            ) VALUES (\n                NEW.invoice_id,\n                'PAYMENT_UPDATED',\n                now(),\n                'Платеж обновлен',\n                'Обновлен платеж ' || COALESCE(NEW.internal_number, 'ID:' || NEW.id),\n                NEW.id,\n                OLD.status,\n                NEW.status,\n                OLD.total_amount,\n                NEW.total_amount,\n                to_jsonb(OLD),\n                to_jsonb(NEW),\n                auth.uid()\n            );\n        END IF;\n        RETURN NEW;\n    END IF;\n\n    RETURN NULL;\nEND;\n$function$\n"
  },
  "public.universal_update_updated_at()": {
    "schema": "public",
    "name": "universal_update_updated_at",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.universal_update_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
  },
  "public.user_has_role(check_role text)": {
    "schema": "public",
    "name": "user_has_role",
    "arguments": "check_role text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION public.user_has_role(check_role text)\n RETURNS boolean\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\n    SELECT EXISTS (\n        SELECT 1 FROM public.users \n        WHERE id = auth.uid() \n        AND role = check_role\n        AND is_active = true\n    );\n$function$\n"
  },
  "realtime.apply_rls(wal jsonb, max_record_bytes integer)": {
    "schema": "realtime",
    "name": "apply_rls",
    "arguments": "wal jsonb, max_record_bytes integer",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))\n RETURNS SETOF realtime.wal_rls\n LANGUAGE plpgsql\nAS $function$\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n$function$\n"
  },
  "realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text)": {
    "schema": "realtime",
    "name": "broadcast_changes",
    "arguments": "topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n$function$\n"
  },
  "realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])": {
    "schema": "realtime",
    "name": "build_prepared_statement_sql",
    "arguments": "prepared_statement_name text, entity regclass, columns realtime.wal_column[]",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])\n RETURNS text\n LANGUAGE sql\nAS $function$\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      $function$\n"
  },
  "realtime.cast(val text, type_ regtype)": {
    "schema": "realtime",
    "name": "cast",
    "arguments": "val text, type_ regtype",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    $function$\n"
  },
  "realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)": {
    "schema": "realtime",
    "name": "check_equality_op",
    "arguments": "op realtime.equality_op, type_ regtype, val_1 text, val_2 text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      $function$\n"
  },
  "realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])": {
    "schema": "realtime",
    "name": "is_visible_through_filters",
    "arguments": "columns realtime.wal_column[], filters realtime.user_defined_filter[]",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    $function$\n"
  },
  "realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)": {
    "schema": "realtime",
    "name": "list_changes",
    "arguments": "publication name, slot_name name, max_changes integer, max_record_bytes integer",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)\n RETURNS SETOF realtime.wal_rls\n LANGUAGE sql\n SET log_min_messages TO 'fatal'\nAS $function$\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    $function$\n"
  },
  "realtime.quote_wal2json(entity regclass)": {
    "schema": "realtime",
    "name": "quote_wal2json",
    "arguments": "entity regclass",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    $function$\n"
  },
  "realtime.send(payload jsonb, event text, topic text, private boolean)": {
    "schema": "realtime",
    "name": "send",
    "arguments": "payload jsonb, event text, topic text, private boolean",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      PERFORM pg_notify(\n          'realtime:system',\n          jsonb_build_object(\n              'error', SQLERRM,\n              'function', 'realtime.send',\n              'event', event,\n              'topic', topic,\n              'private', private\n          )::text\n      );\n  END;\nEND;\n$function$\n"
  },
  "realtime.subscription_check_filters()": {
    "schema": "realtime",
    "name": "subscription_check_filters",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n"
  },
  "realtime.to_regrole(role_name text)": {
    "schema": "realtime",
    "name": "to_regrole",
    "arguments": "role_name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)\n RETURNS regrole\n LANGUAGE sql\n IMMUTABLE\nAS $function$ select role_name::regrole $function$\n"
  },
  "realtime.topic()": {
    "schema": "realtime",
    "name": "topic",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION realtime.topic()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect nullif(current_setting('realtime.topic', true), '')::text;\n$function$\n"
  },
  "storage.add_prefixes(_bucket_id text, _name text)": {
    "schema": "storage",
    "name": "add_prefixes",
    "arguments": "_bucket_id text, _name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    prefixes text[];\nBEGIN\n    prefixes := \"storage\".\"get_prefixes\"(\"_name\");\n\n    IF array_length(prefixes, 1) > 0 THEN\n        INSERT INTO storage.prefixes (name, bucket_id)\n        SELECT UNNEST(prefixes) as name, \"_bucket_id\" ON CONFLICT DO NOTHING;\n    END IF;\nEND;\n$function$\n"
  },
  "storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)": {
    "schema": "storage",
    "name": "can_insert_object",
    "arguments": "bucketid text, name text, owner uuid, metadata jsonb",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n"
  },
  "storage.delete_prefix(_bucket_id text, _name text)": {
    "schema": "storage",
    "name": "delete_prefix",
    "arguments": "_bucket_id text, _name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if we can delete the prefix\n    IF EXISTS(\n        SELECT FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"prefixes\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    )\n    OR EXISTS(\n        SELECT FROM \"storage\".\"objects\"\n        WHERE \"objects\".\"bucket_id\" = \"_bucket_id\"\n          AND \"storage\".\"get_level\"(\"objects\".\"name\") = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"objects\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    ) THEN\n    -- There are sub-objects, skip deletion\n    RETURN false;\n    ELSE\n        DELETE FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\")\n          AND \"prefixes\".\"name\" = \"_name\";\n        RETURN true;\n    END IF;\nEND;\n$function$\n"
  },
  "storage.delete_prefix_hierarchy_trigger()": {
    "schema": "storage",
    "name": "delete_prefix_hierarchy_trigger",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    prefix text;\nBEGIN\n    prefix := \"storage\".\"get_prefix\"(OLD.\"name\");\n\n    IF coalesce(prefix, '') != '' THEN\n        PERFORM \"storage\".\"delete_prefix\"(OLD.\"bucket_id\", prefix);\n    END IF;\n\n    RETURN OLD;\nEND;\n$function$\n"
  },
  "storage.enforce_bucket_name_length()": {
    "schema": "storage",
    "name": "enforce_bucket_name_length",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n    if length(new.name) > 100 then\n        raise exception 'bucket name \"%\" is too long (% characters). Max is 100.', new.name, length(new.name);\n    end if;\n    return new;\nend;\n$function$\n"
  },
  "storage.extension(name text)": {
    "schema": "storage",
    "name": "extension",
    "arguments": "name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\n    _filename text;\nBEGIN\n    SELECT string_to_array(name, '/') INTO _parts;\n    SELECT _parts[array_length(_parts,1)] INTO _filename;\n    RETURN reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n"
  },
  "storage.filename(name text)": {
    "schema": "storage",
    "name": "filename",
    "arguments": "name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n"
  },
  "storage.foldername(name text)": {
    "schema": "storage",
    "name": "foldername",
    "arguments": "name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\nBEGIN\n    -- Split on \"/\" to get path segments\n    SELECT string_to_array(name, '/') INTO _parts;\n    -- Return everything except the last segment\n    RETURN _parts[1 : array_length(_parts,1) - 1];\nEND\n$function$\n"
  },
  "storage.get_level(name text)": {
    "schema": "storage",
    "name": "get_level",
    "arguments": "name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.get_level(name text)\n RETURNS integer\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT array_length(string_to_array(\"name\", '/'), 1);\n$function$\n"
  },
  "storage.get_prefix(name text)": {
    "schema": "storage",
    "name": "get_prefix",
    "arguments": "name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.get_prefix(name text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT\n    CASE WHEN strpos(\"name\", '/') > 0 THEN\n             regexp_replace(\"name\", '[\\/]{1}[^\\/]+\\/?$', '')\n         ELSE\n             ''\n        END;\n$function$\n"
  },
  "storage.get_prefixes(name text)": {
    "schema": "storage",
    "name": "get_prefixes",
    "arguments": "name text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE STRICT\nAS $function$\nDECLARE\n    parts text[];\n    prefixes text[];\n    prefix text;\nBEGIN\n    -- Split the name into parts by '/'\n    parts := string_to_array(\"name\", '/');\n    prefixes := '{}';\n\n    -- Construct the prefixes, stopping one level below the last part\n    FOR i IN 1..array_length(parts, 1) - 1 LOOP\n            prefix := array_to_string(parts[1:i], '/');\n            prefixes := array_append(prefixes, prefix);\n    END LOOP;\n\n    RETURN prefixes;\nEND;\n$function$\n"
  },
  "storage.get_size_by_bucket()": {
    "schema": "storage",
    "name": "get_size_by_bucket",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::bigint) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n"
  },
  "storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text)": {
    "schema": "storage",
    "name": "list_multipart_uploads_with_delimiter",
    "arguments": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n"
  },
  "storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text)": {
    "schema": "storage",
    "name": "list_objects_with_delimiter",
    "arguments": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n$function$\n"
  },
  "storage.objects_insert_prefix_trigger()": {
    "schema": "storage",
    "name": "objects_insert_prefix_trigger",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    NEW.level := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  "storage.objects_update_prefix_trigger()": {
    "schema": "storage",
    "name": "objects_update_prefix_trigger",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.objects_update_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    old_prefixes TEXT[];\nBEGIN\n    -- Ensure this is an update operation and the name has changed\n    IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN\n        -- Retrieve old prefixes\n        old_prefixes := \"storage\".\"get_prefixes\"(OLD.\"name\");\n\n        -- Remove old prefixes that are only used by this object\n        WITH all_prefixes as (\n            SELECT unnest(old_prefixes) as prefix\n        ),\n        can_delete_prefixes as (\n             SELECT prefix\n             FROM all_prefixes\n             WHERE NOT EXISTS (\n                 SELECT 1 FROM \"storage\".\"objects\"\n                 WHERE \"bucket_id\" = OLD.\"bucket_id\"\n                   AND \"name\" <> OLD.\"name\"\n                   AND \"name\" LIKE (prefix || '%')\n             )\n         )\n        DELETE FROM \"storage\".\"prefixes\" WHERE name IN (SELECT prefix FROM can_delete_prefixes);\n\n        -- Add new prefixes\n        PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    END IF;\n    -- Set the new level\n    NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  "storage.operation()": {
    "schema": "storage",
    "name": "operation",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n"
  },
  "storage.prefixes_insert_trigger()": {
    "schema": "storage",
    "name": "prefixes_insert_trigger",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    RETURN NEW;\nEND;\n$function$\n"
  },
  "storage.search(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text)": {
    "schema": "storage",
    "name": "search",
    "arguments": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    can_bypass_rls BOOLEAN;\nbegin\n    SELECT rolbypassrls\n    INTO can_bypass_rls\n    FROM pg_roles\n    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);\n\n    IF can_bypass_rls THEN\n        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    ELSE\n        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    END IF;\nend;\n$function$\n"
  },
  "storage.search_legacy_v1(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text)": {
    "schema": "storage",
    "name": "search_legacy_v1",
    "arguments": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select path_tokens[$1] as folder\n           from storage.objects\n             where objects.name ilike $2 || $3 || ''%''\n               and bucket_id = $4\n               and array_length(objects.path_tokens, 1) <> $1\n           group by folder\n           order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  "storage.search_v1_optimised(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text)": {
    "schema": "storage",
    "name": "search_v1_optimised",
    "arguments": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select (string_to_array(name, ''/''))[level] as name\n           from storage.prefixes\n             where lower(prefixes.name) like lower($2 || $3) || ''%''\n               and bucket_id = $4\n               and level = $1\n           order by name ' || v_sort_order || '\n     )\n     (select name,\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[level] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where lower(objects.name) like lower($2 || $3) || ''%''\n       and bucket_id = $4\n       and level = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  "storage.search_v2(prefix text, bucket_name text, limits integer, levels integer, start_after text)": {
    "schema": "storage",
    "name": "search_v2",
    "arguments": "prefix text, bucket_name text, limits integer, levels integer, start_after text",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text)\n RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN query EXECUTE\n        $sql$\n        SELECT * FROM (\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name || '/' AS name,\n                    NULL::uuid AS id,\n                    NULL::timestamptz AS updated_at,\n                    NULL::timestamptz AS created_at,\n                    NULL::jsonb AS metadata\n                FROM storage.prefixes\n                WHERE name COLLATE \"C\" LIKE $1 || '%'\n                AND bucket_id = $2\n                AND level = $4\n                AND name COLLATE \"C\" > $5\n                ORDER BY prefixes.name COLLATE \"C\" LIMIT $3\n            )\n            UNION ALL\n            (SELECT split_part(name, '/', $4) AS key,\n                name,\n                id,\n                updated_at,\n                created_at,\n                metadata\n            FROM storage.objects\n            WHERE name COLLATE \"C\" LIKE $1 || '%'\n                AND bucket_id = $2\n                AND level = $4\n                AND name COLLATE \"C\" > $5\n            ORDER BY name COLLATE \"C\" LIMIT $3)\n        ) obj\n        ORDER BY name COLLATE \"C\" LIMIT $3;\n        $sql$\n        USING prefix, bucket_name, limits, levels, start_after;\nEND;\n$function$\n"
  },
  "storage.update_updated_at_column()": {
    "schema": "storage",
    "name": "update_updated_at_column",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n"
  },
  "supabase_functions.http_request()": {
    "schema": "supabase_functions",
    "name": "http_request",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION supabase_functions.http_request()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'supabase_functions'\nAS $function$\n    DECLARE\n      request_id bigint;\n      payload jsonb;\n      url text := TG_ARGV[0]::text;\n      method text := TG_ARGV[1]::text;\n      headers jsonb DEFAULT '{}'::jsonb;\n      params jsonb DEFAULT '{}'::jsonb;\n      timeout_ms integer DEFAULT 1000;\n    BEGIN\n      IF url IS NULL OR url = 'null' THEN\n        RAISE EXCEPTION 'url argument is missing';\n      END IF;\n\n      IF method IS NULL OR method = 'null' THEN\n        RAISE EXCEPTION 'method argument is missing';\n      END IF;\n\n      IF TG_ARGV[2] IS NULL OR TG_ARGV[2] = 'null' THEN\n        headers = '{\"Content-Type\": \"application/json\"}'::jsonb;\n      ELSE\n        headers = TG_ARGV[2]::jsonb;\n      END IF;\n\n      IF TG_ARGV[3] IS NULL OR TG_ARGV[3] = 'null' THEN\n        params = '{}'::jsonb;\n      ELSE\n        params = TG_ARGV[3]::jsonb;\n      END IF;\n\n      IF TG_ARGV[4] IS NULL OR TG_ARGV[4] = 'null' THEN\n        timeout_ms = 1000;\n      ELSE\n        timeout_ms = TG_ARGV[4]::integer;\n      END IF;\n\n      CASE\n        WHEN method = 'GET' THEN\n          SELECT http_get INTO request_id FROM net.http_get(\n            url,\n            params,\n            headers,\n            timeout_ms\n          );\n        WHEN method = 'POST' THEN\n          payload = jsonb_build_object(\n            'old_record', OLD,\n            'record', NEW,\n            'type', TG_OP,\n            'table', TG_TABLE_NAME,\n            'schema', TG_TABLE_SCHEMA\n          );\n\n          SELECT http_post INTO request_id FROM net.http_post(\n            url,\n            payload,\n            params,\n            headers,\n            timeout_ms\n          );\n        ELSE\n          RAISE EXCEPTION 'method argument % is invalid', method;\n      END CASE;\n\n      INSERT INTO supabase_functions.hooks\n        (hook_table_id, hook_name, request_id)\n      VALUES\n        (TG_RELID, TG_NAME, request_id);\n\n      RETURN NEW;\n    END\n  $function$\n"
  },
  "vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea)": {
    "schema": "vault",
    "name": "_crypto_aead_det_decrypt",
    "arguments": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$\n"
  },
  "vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea)": {
    "schema": "vault",
    "name": "_crypto_aead_det_encrypt",
    "arguments": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$\n"
  },
  "vault._crypto_aead_det_noncegen()": {
    "schema": "vault",
    "name": "_crypto_aead_det_noncegen",
    "arguments": "",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$\n"
  },
  "vault.create_secret(new_secret text, new_name text, new_description text, new_key_id uuid)": {
    "schema": "vault",
    "name": "create_secret",
    "arguments": "new_secret text, new_name text, new_description text, new_key_id uuid",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  rec record;\nBEGIN\n  INSERT INTO vault.secrets (secret, name, description)\n  VALUES (\n    new_secret,\n    new_name,\n    new_description\n  )\n  RETURNING * INTO rec;\n  UPDATE vault.secrets s\n  SET secret = encode(vault._crypto_aead_det_encrypt(\n    message := convert_to(rec.secret, 'utf8'),\n    additional := convert_to(s.id::text, 'utf8'),\n    key_id := 0,\n    context := 'pgsodium'::bytea,\n    nonce := rec.nonce\n  ), 'base64')\n  WHERE id = rec.id;\n  RETURN rec.id;\nEND\n$function$\n"
  },
  "vault.update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid)": {
    "schema": "vault",
    "name": "update_secret",
    "arguments": "secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid",
    "comment": null,
    "sql": "CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);\nBEGIN\n  UPDATE vault.secrets s\n  SET\n    secret = CASE WHEN new_secret IS NULL THEN s.secret\n                  ELSE encode(vault._crypto_aead_det_encrypt(\n                    message := convert_to(new_secret, 'utf8'),\n                    additional := convert_to(s.id::text, 'utf8'),\n                    key_id := 0,\n                    context := 'pgsodium'::bytea,\n                    nonce := s.nonce\n                  ), 'base64') END,\n    name = coalesce(new_name, s.name),\n    description = coalesce(new_description, s.description),\n    updated_at = now()\n  WHERE s.id = secret_id;\nEND\n$function$\n"
  }
}